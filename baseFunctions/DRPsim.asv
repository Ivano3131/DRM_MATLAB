function [simDRP] = DRPsim(eu1,eu2,eu3,exp_para)
% the function is to simulate DRP based on Phong model.
% input Euler angle triplets are in Bunge convention.
% Edit date: Sep 14, 2021
% By: Chenyang ZHU @ NTU
% -------------------------------------------------------------------------
arguments
    eu1 double
    eu2 double
    eu3 double
    exp_para struct
end

th_max = exp_para.th_max;
th_min = exp_para.th_min;
th_num = exp_para.th_num;
ph_num = exp_para.ph_num;
faceting = exp_para.faceting;
i_Main = exp_para.fitting_para(1); % peak of point reflectance
i_facet = exp_para.fitting_para(2);
sd_Main = exp_para.fitting_para(3); % width of point reflectance
sd_facet = exp_para.fitting_para(4);

%rot_facet = normr(rotate_facet(eu1,eu2,eu3,faceting)); % normr normalizes
[rot_facet, faceW, pairW] = rotate_facet(eu1, eu2, eu3, faceting);
th_step = (th_max - th_min) / (th_num - 1);
ph_step = 360 / ph_num;

cauchy = @(p,x) p(1) ./ ((1+((x)./p(2)).^2)); %creates a function to model the intensity
% i_main / (1 + (peakDist/sd_main)^2)

%cauchy = @(p,x) p(1) * cosd(x) ./ p(2);

% shininess is not considered

th_range = th_min-th_step : th_step : ...
    (floor((90-th_min)/th_step)-1)*th_step+th_min;
th_DRP=repmat(transpose(th_range),1,ph_num);
ph_DRP=repmat(0:ph_step:360-ph_step,length(th_range),1);
simDRP=zeros(length(th_range),ph_num);
vec_DRP=zeros(3,length(th_range),ph_num);

% generate the vectors of incident/reflectance beams
for ii = 1:length(th_range)
    for jj = 1:ph_num
        tmp_vec = thph2vec(45+th_DRP(ii,jj)/2, ph_DRP(ii,jj)); %equally spaced theta and phi to vector
        vec_DRP(:,ii,jj) = normr(tmp_vec);
    end
end

temp_simDRP = 0;
temp_simDRP_pair = 0;

% major reflectance peak simulation
for ii = 1:size(rot_facet,1)
    ref_a1 = rot_facet(ii,:); % N1 - microfacet
    ref = [0 0 -1] - 2 * dot([0 0 -1], ref_a1) * ref_a1; % incident direction of the primary reflection
    tmp_thph = vec2thph(ref);
    tmp_theta = tmp_thph(1);
    dPh=abs(ph_DRP - tmp_thph(2)); % difference in phi
    dPh=abs(dPh - 360 * (dPh>180));
    peakDist=acosd(sind(th_DRP)*sind(tmp_theta)+cosd(th_DRP)*cosd(tmp_theta).*cosd(dPh)); % angular distance between the current point in DRP and the primary reflection direction
    %simDRP = max(simDRP, faceW(ii)*cauchy([i_Main, sd_Main], peakDist)); % maximum between current value and the new value due to Cauchy distribution
    %length(faceW)
    temp_simDRP = temp_simDRP + faceW(ii) * cauchy([i_Main, sd_Main], peakDist);
    simDRP = max(temp_simDRP, simDRP);
end

% great circle band simulation
for ii = 1:size(rot_facet,1)
    for jj = 1:size(rot_facet,1)
        if ii == jj
            continue
        end
        vec_1 = rot_facet(ii,:);
        vec_2 = rot_facet(jj,:); % these should be identical
        if all(vec_1 - vec_2 < 1e-3) || all(vec_1 + vec_2 < 1e-3)
            continue
        end
        gcnorm = normr(cross(vec_1, vec_2)); % should be zero
        peakDistb=zeros(size(simDRP));
        peakDista=zeros(size(simDRP));
        bandDist=zeros(size(simDRP));
        for mm = 1:length(th_range)
            for nn = 1:ph_num
                peakDista(mm,nn) = acosd(dot(vec_1, vec_DRP(:,mm,nn))); % angular distance between the current point in DRP and the first microfacet
                peakDistb(mm,nn) = acosd(dot(vec_2, vec_DRP(:,mm,nn))); % angular distance between the current point in DRP and the second microfacet
                % should be the same as the previous line
                bandDist(mm,nn) = asind(dot(gcnorm, vec_DRP(:,mm,nn))); % angular distance between the current point in DRP and the great circle defined by the two microfacets
            end
        end
        %         peakDist = bandDist; % + min(peakDista, peakDistb).^2.5;
        temp_simDRP_pair = temp_simDRP_pair + pairW(ii) * cauchy([i_facet, sd_facet], bandDist);
        %simDRP = max(simDRP, pairW(ii, jj)*cauchy([i_facet, sd_facet], bandDist));
        simDRP = max(simDRP, temp_simDRP_pair);
    end
end

simDRP = simDRP - min(simDRP(:));
if max(simDRP(:)) > 0
    simDRP = simDRP / max(simDRP(:));
end

simDRP=uint8(simDRP(2:th_num+1,:)*255);

end